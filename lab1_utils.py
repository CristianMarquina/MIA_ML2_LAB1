import math
from collections import deque

# Online Libraries (River)
from river import base


# --- Function to generate BATCH Features (Pandas) ---
def get_batch_features_and_target(df_in):
    """
    Calculates the same metrics as the River class but vectorized using Pandas.
    """
    df_temp = df_in.copy()
    
    # Return: (Current Close Price - Previous Close Price) / Previous Close Price
    df_temp['Return'] = df_temp['Close'].pct_change()
    
    # Rolling Means (Windows 5 and 20)
    df_temp['Mean_return_5'] = df_temp['Return'].rolling(window=5).mean()
    df_temp['Mean_return_20'] = df_temp['Return'].rolling(window=20).mean()
    
    # Volatility (Window 20 std)
    # IMPORTANT: ddof=0 to match the population standard deviation formula used in the River class
    df_temp['Volatility_20'] = df_temp['Return'].rolling(window=20).std(ddof=0)
    
    # Open-Close Difference
    df_temp['Open_Close_Diff'] = df_temp['Close'] - df_temp['Open']
    
    # Volume Deviation (Current Volume - Average Volume of last 20 days)
    df_temp['Volume_dev'] = df_temp['Volume'] - df_temp['Volume'].rolling(window=20).mean()
    
    # Remove rows with NaNs generated by rolling windows (the first 20 rows)
    df_temp = df_temp.dropna()
    
    # Separate X (Features) and y (Target)
    features = ['Close', 'Return', 'Mean_return_5', 'Mean_return_20', 
                'Volatility_20', 'Open_Close_Diff', 'Volume', 'Volume_dev']
    
    
    X = df_temp[features]
    y = df_temp['Target_High']
    
    return X, y


# --- Class for ONLINE Features (River) ---
class OnlineSPYFeatures(base.Transformer):

    def __init__(self):
        self.prev_close = None
        
        self.window_5 = deque(maxlen=5)
        self.window_20 = deque(maxlen=20)
        self.volume_window_20 = deque(maxlen=20)

    def mean(self, window):
        return sum(window) / len(window) if window else 0.0

    def std(self, window):
        if len(window) < 2:
            return 0.0
        m = self.mean(window)
        return math.sqrt(sum((x - m) ** 2 for x in window) / len(window))

    def transform_one(self, x):

        close = x["Close"]
        volume = x["Volume"]
        open_ = x["Open"]

        # Compute return
        if self.prev_close is not None:
            ret = (close - self.prev_close) / self.prev_close
        else:
            ret = 0.0

        # Update rolling windows
        self.window_5.append(ret)
        self.window_20.append(ret)
        self.volume_window_20.append(volume)

        features = {
            "Close": close,
            "Return": ret,
            "Mean_return_5": self.mean(self.window_5),
            "Mean_return_20": self.mean(self.window_20),
            "Volatility_20": self.std(self.window_20),
            "Open_Close_Diff": close - open_,
            "Volume": volume,
            "Volume_dev": volume - self.mean(self.volume_window_20),
        }

        self.prev_close = close

        return features